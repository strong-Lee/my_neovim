-- 10个高效的 LazyVim 工作流程和习惯
--
-- 习惯一：以项目为单位启动，以“意图”为导向导航
-- 在你的项目根目录用 vim . 打开。不要思考文件在哪里，而是思考“我要做什么”。
-- 想找一个叫 UserController 的文件？按 <leader>ff 输入 usercon 回车。
-- 想找所有用到 processPayment 函数的地方？按 <leader>fg 输入 processPayment 回车。
-- 这是从“文件树思维”到“搜索/命令思维”的转变，是 Vim 效率的基石。
--
-- 习惯二：利用 LSP 进行代码“阅读”和“理解”
-- 当你看到一个不熟悉的函数或类时，不要去全局搜索它。
-- 光标放在函数上，按 gd (Go to Definition) 直接跳转到它的定义。
-- 想知道这个函数在哪里被调用了？按 gr (Go to References) 查看所有引用。
-- 不确定函数参数？光标放上去，按 K (大写K) 显示文档和签名。
-- 让代码本身成为你的导航地图，LSP 是你的向导。
--
-- 习惯三：高效的文本编辑与修改
-- 写代码时，善用 LazyVim 提供的编辑增强工具。
-- 使用 gc (比如 gcc 注释当前行，gc + 动作 注释选区)。
-- 想给一个单词加上引号？光标在单词上，
--    输入 ysiw" (ys=you surround, iw=inner word, "=with quotes)。
--    想修改？输入 cs"' (change surrounding " to ')。
-- 输入你定义的 pubf，然后按 <Tab> 或 <Enter> 展开。
--
-- 习惯四：无缝的 Git 集成
-- 当你完成一小部分功能后，需要提交代码。你完全不需要离开 Vim。
-- 按 <leader>gg 打开 LazyGit，这是一个极其强大的终端 Git UI。
-- 在 LazyGit 中，你可以用 j/k 上下移动，用 <space> 暂存文件，按 c 提交，按 P 推送。所有 Git 操作一站式完成。
-- 在编辑器中，左侧的 Git signs (小竖条) 会告诉你哪些行是新增或修改的。
-- 将版本控制融入到你的编辑环境中，保持心流不被打断。
--
-- 习惯五：原子化的重构
-- 当你需要重命名一个变量或函数时，千万不要用搜索替换。
-- 光标放在要重构的变量/函数上，按 <leader>cr (Code Rename)。
-- 输入新名字，回车。LSP 会智能地在整个项目中所有相关的地方进行重命名，绝不会改错。
-- 利用工具保证重构的安全性和准确性。
--
-- 习惯六：灵活的终端调用
-- 有时需要执行一个 composer install 或者跑一个测试脚本。
-- 按 <leader>t 调出浮动终端，输入命令，执行完再按一次 <leader>t 关掉。
-- 或者按 <leader>sT 在下方打开一个常驻终端面板。
-- 快速执行命令，但不让终端长期占据你的屏幕空间。
--
-- 习惯七：缓冲区(Buffer)就是你的工作区
-- 把这些文件都打开一遍，它们就都在你的缓冲区列表里了。
-- 使用 <leader>b 或你自定义的 <C-Left/Right> 在它们之间快速切换。
-- 某个文件暂时不用了？按 <leader>q 关闭它。
-- 把 Buffer 当作你的“当前工作集”，而不是每次都从文件树或搜索里重新找。
--
-- 习惯八：利用诊断信息（Diagnostics）驱动修复
-- 代码写错了，或者不符合规范。
-- 编辑器会自动在有问题的代码下显示波浪线，并在行号处显示图标。
-- 按 ]d 跳转到下一个问题，[d 跳转到上一个。
-- 光标停在问题行，按 <leader>cl (Code Lens/List) 会显示详细错误信息。
-- 让编辑器主动告诉你哪里错了，并快速定位它们。
--
-- 习惯九：分屏与标签页管理上下文
-- 你需要同时查看控制器和视图文件，或者对比两个文件的差异。
-- 使用你定义的 <leader>v (垂直) 和 <leader>s (水平) 分屏。用 <C-h/j/k/l> 在分屏间移动。
-- 如果你在处理两个不相关的任务，可以用 <leader>tn (tab new) 创建一个新标签页，用 <leader>t] 和 <leader>t[ 切换。
-- 合理组织你的屏幕空间，以匹配你的思绪。
--
-- 习惯十：善用 "Which-key" 探索未知
-- 你忘记了某个功能的快捷键，或者想知道某个前缀下有哪些可用命令。
-- 按下 <leader> (空格)，然后等待300毫秒（你在 options.lua 中设置的 timeoutlen）。
-- 一个菜单会弹出，列出所有以 <leader> 开头的快捷键和它们的功能描述。
-- 把 Which-key 当作你的动态备忘录和探索工具，不断发现和学习新的高效操作。
--
-- 习惯十一：使用“宏” (Macro) 终结重复操作
-- 你发现自己需要在多行上执行一系列完全相同的编辑操作（比如：跳到行尾，加个分号，再换行加个注释）。
-- 光标移动到起始行，按 qa (开始录制宏到寄存器 a)。
-- 执行你那套重复操作，比如 A;<Esc>o// TODO<Esc>j。
-- 按 q 停止录制。
-- 现在，到下一行按 @a，就会完美重放刚才的所有操作。要重复10次？输入 10@a。
-- “不要重复自己”不仅是代码原则，也是编辑原则。宏是Vim的终极自动化武器。
--
-- 习惯十二：文本对象 (Text Objects) 精准打击
-- 你想修改或删除一个完整函数、一对括号/引号里的内容，或者一个XML/HTML标签内的内容。
-- diw (delete inner word) - 删除光标下的单词。
-- ci" (change inner quotes) - 删除双引号内的内容并进入插入模式。
-- vat (visual select around tag) - 选中整个HTML/XML标签（包括标签本身）。
-- dap (delete around paragraph) - 删除整个段落（包括空行）。
-- 从操作“字符”和“行”升级到操作“代码块”和“语义单元”，效率指数级提升。
--
-- 习惯十三：利用 Trouble.nvim 聚合问题
-- 你的项目里有多个错误、警告、TODO注释，你想在一个地方集中查看和处理它们。
-- 按 <leader>xx 打开 Trouble 窗口，显示当前文件的所有诊断信息。
-- <leader>xL 打开 Trouble 窗口，显示整个项目的所有 LSP 诊断信息。
-- <leader>xt 打开 Trouble 窗口，显示所有的 TODO, FIXME 等注释。
-- 在 Trouble 窗口中按回车可以直接跳转到对应位置。
-- 把“被动”地在代码里找问题，变成“主动”地在一个清单里解决问题。
--
-- 习惯十四：使用 marks (标记) 和 jumplist (跳转列表)
-- 你正在重构一个大功能，需要在3个核心文件之间频繁来回跳转。
-- 在文件A的关键位置按 mA (设置大写标记 A)。
-- 在文件B的关键位置按 mB。
-- 现在，在项目的任何地方，按 'A (单引号+A) 就能瞬间跳回文件A的那个位置。
-- 在这些跳转之后，使用 <C-o> (后退) 和 <C-i> (前进) 在你的跳转历史中穿梭。
-- 大写字母标记是全局的，能让你在项目中建立自己的“传送门”。
--
-- 习惯十五：无鼠标的窗口和分屏管理
-- 你开了多个分屏，需要调整它们的大小或位置。
-- <C-w>h/j/k/l - 在分屏间移动光标。
-- <C-w>> 或 <C-w>< - 增加/减少垂直分屏的宽度。
-- <C-w>+ 或 <C-w>- - 增加/减少水平分屏的高度。
-- <C-w>= - 让所有分屏等宽/等高。
-- <C-w>r - 旋转分屏。
-- 彻底摆脱鼠标，让你的双手始终停留在键盘主区域。
--
